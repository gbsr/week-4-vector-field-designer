import type { InfluenceNode } from "./state/nodes"

function serializeNode(node: InfluenceNode): string {
  const parts: string[] = []

  parts.push(`kind: "${node.kind}"`)
  parts.push(`x: ${node.x}`)
  parts.push(`y: ${node.y}`)
  parts.push(`force: ${node.force}`)
  parts.push(`radius: ${node.radius}`)
  parts.push(`falloff: "${node.falloff}"`)

  if (node.directionDeg != null) {
    parts.push(`directionDeg: ${node.directionDeg}`)
  }
  if (node.spin) {
    parts.push(`spin: "${node.spin}"`)
  }

  return `  {\n    ${parts.join(",\n    ")}\n  }`
}

// very small HTML escaper so code displays correctly in <pre><code>
export function escapeHtml(str: string): string {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
}

export function generateFieldModule(nodes: InfluenceNode[]): string {
  const nodeLines = nodes.map(serializeNode).join(",\n\n")

  return `// Generated by Flow Field Designer
// Paste this into your project and call \`evaluateField(pos, FIELD_NODES)\`.

export type NodeKind = "attract" | "repel" | "flow" | "vortex"
export type Falloff = "linear" | "smooth"
export type Spin = "cw" | "ccw"

export interface InfluenceNode {
  kind: NodeKind

  // field origin (world space)
  x: number
  y: number

  force: number
  radius: number
  falloff: Falloff
  directionDeg?: number // flow
  spin?: Spin // vortex
}

export interface Vec2 {
  x: number
  y: number
}

// --- field definition (from editor) ---

export const FIELD_NODES: InfluenceNode[] = [
${nodeLines}
]

// --- field math ---

function falloffFactor(dist: number, radius: number, mode: Falloff): number {
  if (dist >= radius) return 0
  const t = 1 - dist / radius
  if (mode === "linear") return t
  // smooth
  return t * t * (3 - 2 * t)
}

function degToRad(deg: number): number {
  return (deg * Math.PI) / 180
}

export function evaluateField(pos: Vec2, nodes: InfluenceNode[]): Vec2 {
  let vx = 0
  let vy = 0

  for (const node of nodes) {
    const dx = pos.x - node.x
    const dy = pos.y - node.y
    const dist = Math.hypot(dx, dy)
    if (dist === 0) continue

    const f = falloffFactor(dist, node.radius, node.falloff)
    if (f === 0) continue

    const nx = dx / dist
    const ny = dy / dist

    if (node.kind === "attract") {
      const s = -node.force * f
      vx += nx * s
      vy += ny * s
    } else if (node.kind === "repel") {
      const s = node.force * f
      vx += nx * s
      vy += ny * s
    } else if (node.kind === "flow") {
      const angle = degToRad(node.directionDeg ?? 0)
      const fx = Math.cos(angle)
      const fy = Math.sin(angle)
      const s = node.force * f
      vx += fx * s
      vy += fy * s
    } else if (node.kind === "vortex") {
      const spin = node.spin ?? "ccw"
      const tx = spin === "ccw" ? -ny : ny
      const ty = spin === "ccw" ? nx : -nx
      const s = node.force * f
      vx += tx * s
      vy += ty * s
    }
  }

  return { x: vx, y: vy }
}

// Example usage:
//
// const acc = evaluateField(boid.position, FIELD_NODES)
// boid.vx += acc.x * dt
// boid.vy += acc.y * dt
// boid.x  += boid.vx * dt
// boid.y  += boid.vy * dt
`
}

// --- tiny TS/JS highlighter (instead of external libs like Prism.js, so we can run directly in client ^^) ---

const KEYWORDS = new Set([
  "export",
  "import",
  "from",
  "const",
  "let",
  "var",
  "function",
  "return",
  "if",
  "else",
  "for",
  "of",
  "in",
  "while",
  "type",
  "interface",
  "extends",
  "implements",
  "new",
  "class",
  "switch",
  "case",
  "break",
  "default",
  "as",
  "number",
  "string",
  "boolean",
  "void",
  "any",
  "unknown",
])

type TokenKind = "plain" | "string" | "comment"

interface Token {
  kind: TokenKind
  text: string
}

function tokenize(code: string): Token[] {
  const tokens: Token[] = []
  let current = ""
  let kind: TokenKind = "plain"

  let i = 0
  const len = code.length

  function push() {
    if (!current) return
    tokens.push({ kind, text: current })
    current = ""
  }

  while (i < len) {
    const ch = code[i]
    const next = i + 1 < len ? code[i + 1] : ""

    // line comment
    if (kind === "plain" && ch === "/" && next === "/") {
      push()
      kind = "comment"
      current += ch
      i++
      current += code[i]
      i++
      // consume until newline
      while (i < len && code[i] !== "\n") {
        current += code[i++]
      }
      push()
      kind = "plain"
      continue
    }

    // block comment
    if (kind === "plain" && ch === "/" && next === "*") {
      push()
      kind = "comment"
      current += ch
      i++
      current += code[i]
      i++
      while (i < len) {
        const c = code[i]
        const n = i + 1 < len ? code[i + 1] : ""
        current += c
        i++
        if (c === "*" && n === "/") {
          current += n
          i++
          break
        }
      }
      push()
      kind = "plain"
      continue
    }

    // strings
    if (kind === "plain" && (ch === '"' || ch === "'" || ch === "`")) {
      push()
      const quote = ch
      kind = "string"
      current += ch
      i++
      while (i < len) {
        const c = code[i]
        current += c
        i++
        if (c === "\\" && i < len) {
          // escaped char
          current += code[i]
          i++
          continue
        }
        if (c === quote) break
      }
      push()
      kind = "plain"
      continue
    }

    current += ch
    i++
  }
  push()
  return tokens
}

function highlightPlain(escaped: string): string {
  // escapeHtml already ran, so we only see plain ASCII, '&lt;', etc.
  return escaped.replace(
    /(\b[A-Za-z_][A-Za-z0-9_]*\b|\b\d+(?:\.\d+)?\b)/g,
    (match) => {
      // numbers
      if (/^\d/.test(match)) {
        return `<span class="tok-number">${match}</span>`
      }

      // keywords
      if (KEYWORDS.has(match)) {
        return `<span class="tok-kw">${match}</span>`
      }

      // simple guess: Types / interfaces / enums start with uppercase
      if (/^[A-Z]/.test(match)) {
        return `<span class="tok-type">${match}</span>`
      }

      return match
    }
  )
}

export function highlightTs(code: string): string {
  const tokens = tokenize(code)
  let out = ""

  for (const t of tokens) {
    if (t.kind === "comment") {
      out += `<span class="tok-comment">${escapeHtml(t.text)}</span>`
    } else if (t.kind === "string") {
      out += `<span class="tok-string">${escapeHtml(t.text)}</span>`
    } else {
      // plain â†’ escape then decorate keywords / numbers / types
      out += highlightPlain(escapeHtml(t.text))
    }
  }

  return out
}
