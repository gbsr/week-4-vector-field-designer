import type { InfluenceNode } from "./state/nodes"

function serializeNode(node: InfluenceNode): string {
  const parts: string[] = []

  parts.push(`kind: "${node.kind}"`)
  parts.push(`x: ${node.x}`)
  parts.push(`y: ${node.y}`)
  parts.push(`force: ${node.force}`)
  parts.push(`radius: ${node.radius}`)
  parts.push(`falloff: "${node.falloff}"`)

  if (node.directionDeg != null) {
    parts.push(`directionDeg: ${node.directionDeg}`)
  }
  if (node.spin) {
    parts.push(`spin: "${node.spin}"`)
  }

  return `  {\n    ${parts.join(",\n    ")}\n  }`
}

// very small HTML escaper so code displays correctly in <pre><code>
export function escapeHtml(str: string): string {
  return str.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;")
}

export function generateFieldModule(nodes: InfluenceNode[]): string {
  const nodeLines = nodes.map(serializeNode).join(",\n\n")

  return `// Generated by Flow Field Designer
// Paste this into your project and call \`evaluateField(pos, FIELD_NODES)\`.

export type NodeKind = "attract" | "repel" | "flow" | "vortex"
export type Falloff = "linear" | "smooth"
export type Spin = "cw" | "ccw"

export interface InfluenceNode {
  kind: NodeKind

  // field origin (world space)
  x: number
  y: number

  force: number
  radius: number
  falloff: Falloff
  directionDeg?: number // flow
  spin?: Spin // vortex
}

export interface Vec2 {
  x: number
  y: number
}

// --- field definition (from editor) ---

export const FIELD_NODES: InfluenceNode[] = [
${nodeLines}
]

// --- field math ---

function falloffFactor(dist: number, radius: number, mode: Falloff): number {
  if (dist >= radius) return 0
  const t = 1 - dist / radius
  if (mode === "linear") return t
  // smooth
  return t * t * (3 - 2 * t)
}

function degToRad(deg: number): number {
  return (deg * Math.PI) / 180
}

export function evaluateField(pos: Vec2, nodes: InfluenceNode[]): Vec2 {
  let vx = 0
  let vy = 0

  for (const node of nodes) {
    const dx = pos.x - node.x
    const dy = pos.y - node.y
    const dist = Math.hypot(dx, dy)
    if (dist === 0) continue

    const f = falloffFactor(dist, node.radius, node.falloff)
    if (f === 0) continue

    const nx = dx / dist
    const ny = dy / dist

    if (node.kind === "attract") {
      const s = -node.force * f
      vx += nx * s
      vy += ny * s
    } else if (node.kind === "repel") {
      const s = node.force * f
      vx += nx * s
      vy += ny * s
    } else if (node.kind === "flow") {
      const angle = degToRad(node.directionDeg ?? 0)
      const fx = Math.cos(angle)
      const fy = Math.sin(angle)
      const s = node.force * f
      vx += fx * s
      vy += fy * s
    } else if (node.kind === "vortex") {
      const spin = node.spin ?? "ccw"
      const tx = spin === "ccw" ? -ny : ny
      const ty = spin === "ccw" ? nx : -nx
      const s = node.force * f
      vx += tx * s
      vy += ty * s
    }
  }

  return { x: vx, y: vy }
}

// Example usage:
//
// const acc = evaluateField(boid.position, FIELD_NODES)
// boid.vx += acc.x * dt
// boid.vy += acc.y * dt
// boid.x  += boid.vx * dt
// boid.y  += boid.vy * dt
`
}
